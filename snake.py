"""
Snake Game in Terminal
- Snake moves using arrow keys and eats food to gain points.
- Game ends if snake's head hits walls, obstacles, or its own body.
- After score 10, Level 2 starts with obstacles.
- Superfood appears near obstacles and gives extra points.
- Press Esc to exit the game.
"""

# Terminal handling for character-cell displays
import curses
# Producting random location for snake, foods and obstacles
from random import randint
# Calculating superfood display time
import time

# Returning a window object which represents the whole screen
curses.initscr()
# Returning a new window, (nlines, ncols, begin_y, begin_x)
win = curses.newwin(20, 40, 0, 0)
# escaping sequences generated by some keys (keypad, function keys) will be interpreted by curses
win.keypad(True)
# Echoing of input characters is turned off
curses.noecho()
# Setting the cursor state. visibility is set to 0 for invisible
curses.curs_set(0)
# Drawing a border around the edges of the window
win.border(0)
# If flag is True, getch() will be non-blocking
win.nodelay(True)

snake_symbol = "\u25CF"
snake = [[4, 7], [4, 6], [4, 5]]

food_symbol = "\u25E6"
food = [6, 18]
win.addch(food[0], food[1], food_symbol)

obstacle_symbol = "\u274C"
obstacles = []  # List of obstacles (currently empty)

superfood_symbol = "\u25EF"
superfood = None
superfood_score = 3
superfood_time = 0.0
superfood_duration = 7.0

key = curses.KEY_RIGHT
score = 0
level = 1


def opposite_keys(dir1, dir2):  # Helper function
    return (
        (dir1 == curses.KEY_UP and dir2 == curses.KEY_DOWN) or
        (dir1 == curses.KEY_DOWN and dir2 == curses.KEY_UP) or
        (dir1 == curses.KEY_LEFT and dir2 == curses.KEY_RIGHT) or
        (dir1 == curses.KEY_RIGHT and dir2 == curses.KEY_LEFT)
    )


valid_keys = [curses.KEY_UP, curses.KEY_DOWN,
              curses.KEY_LEFT, curses.KEY_RIGHT]

# ---------- Main Game Loop ----------
while True:
    win.border(0)

    score_y, score_x = 1, 2
    score_text = f"Score: {score}, Level: {level}"
    occupied_positions = [food] + snake + obstacles
    score_positions = [[score_y, score_x + i] for i in range(len(score_text))]

    if not any(pos in occupied_positions for pos in score_positions):
        win.addstr(score_y, score_x, score_text)

    win.timeout(150)

    next_key = win.getch()
    if next_key in valid_keys and not opposite_keys(key, next_key):
        key = next_key
    elif next_key == 27:  # Esc ACCII Code
        break

    y, x = snake[0]
    if key == curses.KEY_DOWN:
        y += 1
    elif key == curses.KEY_UP:
        y -= 1
    elif key == curses.KEY_LEFT:
        x -= 1
    elif key == curses.KEY_RIGHT:
        x += 1
    new_head = [y, x]

    if y == 0 or y == 19 or x == 0 or x == 39 or new_head in snake or new_head in obstacles:
        break

    snake.insert(0, new_head)

    # ---------- Eating Normal Food ----------
    if snake[0] == food:
        score += 1
        food = None
        while food is None:
            nf = [randint(2, 18), randint(1, 38)]
            if nf not in snake and nf not in obstacles:
                food = nf
        win.addch(food[0], food[1], food_symbol)
    else:
        tail = snake.pop()
        win.addch(tail[0], tail[1], ' ')

    # ---------- Handle Superfood Timeout ----------
    if superfood and time.time() - superfood_time > superfood_duration:
        win.addch(superfood[0], superfood[1], ' ')
        superfood = None

    # ---------- Eating Superfood ----------
    if superfood and snake[0] == superfood:
        score += superfood_score
        superfood = None

    # ---------- Level 2 Setup ----------
    if score >= 10 and level == 1:
        level = 2
        for i in range(3):
            while True:
                ob = [randint(2, 18), randint(1, 38)]
                if ob not in snake and ob != food and ob not in obstacles:
                    obstacles.append(ob)
                    break
        for ob in obstacles:
            win.addch(ob[0], ob[1], obstacle_symbol)

    # ---------- Create Superfood ----------
    if level == 2 and superfood is None:
        chosen_ob = obstacles[randint(0, len(obstacles) - 1)]
        possible_positions = [
            [chosen_ob[0] - 1, chosen_ob[1]],
            [chosen_ob[0] + 1, chosen_ob[1]],
            [chosen_ob[0], chosen_ob[1] - 1],
            [chosen_ob[0], chosen_ob[1] + 1],
        ]
        valid_positions = [
            pos for pos in possible_positions
            if 1 <= pos[0] <= 18
            and 1 <= pos[1] <= 38
            and pos not in snake
            and pos != food
            and pos not in obstacles
        ]
        if valid_positions:
            superfood = valid_positions[randint(0, len(valid_positions) - 1)]
            superfood_time = time.time()
            win.addch(superfood[0], superfood[1], superfood_symbol)

    # ---------- Draw Snake ----------
    win.addch(snake[0][0], snake[0][1], snake_symbol)

curses.endwin()
print(f"Game Over! Your final score was {score}")
